z + 1
dim(X)
dim(b)
c <- rep(b, dim(X)[2])
c
dim(c)
c <- apply(b, 2, cbind)
c
c <- t(t(X(,:), b))
c <- t(t(X(,1:dim(X)[2]), b))
c <- t(t(X(,1:dim(X)[2]) + b))
X
c <- t(t(X[,1:dim(X)[2]] + b))
b
b <- b + 2
b
c <- t(t(X[,1:dim(X)[2]]) + b)
t(X[, 1:dim(X)[2]])
?t
c <- apply(X, 2, "-", b)
c
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2: (numLayers)) {
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <-  apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
parameters
res
letsee <- forwardPropagation(X,Y, res, 5, tanh)
parameters - initializeParameters(4, nodes, FALSE)
parameters <- initializeParameters(4, nodes, FALSE)
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2: (numLayers)) {
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <-  apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
parameters <- initializeParameters(4, nodes, FALSE)
View(initializeParameters)
clear(initializeParameters())
rm(initializeParameters)
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2: (numLayers)) {
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <-  apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
parameters <- initializeParameters(4, nodes, FALSE)
initializeParameters <- function(numLayers, numNodes, varControl) {
## numLayers = number of all layers ie. input, output + hidden layers
## numNodes = array for number of nodes in each layer, features for 0 layer
## varControl = variance control mechanism for weights
nodes <- array(numNodes, length(numNodes))
W <- list()
B <- list()
for (i in 2:(numLayers) ) {
W[[i]] <- matrix(rnorm(nodes[i] * (nodes[i - 1])), nodes[i], nodes[i - 1])
B[[i]] <- matrix(rep(0, nodes[i]), nodes[i], 1)
}
## Multiply W with varControl
## Return results
return(list(W = W, B = B))
}
parameters <- initializeParameters(4, nodes, FALSE)
View(initializeParameters)
nodes <- c(4,3,3,1)
nodes
parameters <- initializeParameters(4, nodes, FALSE)
letsee <- forwardPropagation(X,Y, res, 4, tanh)
parameters
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:numLayers) {
message(i)
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <-  apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, res, 4, tanh)
View(A)
parameters
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:numLayers) {
message(parameters$W[[i]])
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, res, 4, tanh)
parameters$W[[1]]
parameters$W[[2]]
parameters$W[[3]]
parameters$W[[4]]
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers-1)) {
message(parameters$W[[i]])
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, res, 4, tanh)
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers-1)) {
message(parameters$W[[i]])
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, res, 4, tanh)
letsee
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(parameters$W[[i]])
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, res, 4, tanh)
parameters$W[[4]]
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(i)
message(parameters$W[[i]])
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, res, 4, tanh)
parameters$W[[4]]
letsee <- forwardPropagation(X,Y, parameters, 4, tanh)
parameters$W[[2]]
X
nodes <- c(3,4,4,3,1)
parameters <- initializeParameters(5, nodes, FALSE)
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
parameters$W[[3]]
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(dims(A[[i-1]]))
message(dims(parameters$W[[i]]))
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
forwardPropagation <- function(X, Y, parameters, numLayers, activation) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(dim(A[[i-1]]))
message(dim(parameters$W[[i]]))
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- activation(Z[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
forwardPropagation <- function(X, Y, parameters, numLayers, FUN = sigmoid) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(dim(A[[i-1]]))
message(dim(parameters$W[[i]]))
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- FUN(Z[[i]],...)
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
forwardPropagation <- function(X, Y, parameters, numLayers, FUN = sigmoid) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(dim(A[[i-1]]))
message(dim(parameters$W[[i]]))
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- FUN(Z[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
forwardPropagation <- function(X, Y, parameters, numLayers, FUN = sigmoid) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(dim(A[[i-1]]))
message(dim(parameters$W[[i]]))
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- FUN(Z[[i]])
message(A[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
forwardPropagation <- function(X, Y, parameters, numLayers, FUN = sigmoid) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(dim(A[[i-1]]))
message(dim(parameters$W[[i]]))
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- FUN(Z[[i]])
message(Z[[i]])
message(A[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
forwardPropagation <- function(X, Y, parameters, numLayers, FUN = sigmoid) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(dim(A[[i-1]]))
message(dim(parameters$W[[i]]))
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$b[[i]])
A[[i]] <- FUN(Z[[i]])
message(wa)
message(Z[[i]])
message(A[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
forwardPropagation <- function(X, Y, parameters, numLayers, FUN = sigmoid) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
message(dim(A[[i-1]]))
message(dim(parameters$W[[i]]))
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$B[[i]])
A[[i]] <- FUN(Z[[i]])
message(wa)
message(Z[[i]])
message(A[[i]])
}
##J <- binaryCost(m, 0, 0)
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
forwardPropagation <- function(X, Y, parameters, numLayers, FUN = sigmoid) {
## parameters containing W and b parameters
## numLayers = number of all layers ie. input, output + hidden layers
## activation = activation function to be used
Z <- list()
A <- list()
A[[1]] <- X
m <- dim(X)[2]
J <- numeric()
for (i in 2:(numLayers)) {
wa <- parameters$W[[i]] %*% A[[i-1]]
Z[[i]] <- apply(wa, 2, "+", parameters$B[[i]])
A[[i]] <- FUN(Z[[i]])
}
J <- -1/m * (Y %*% log(A[[numLayers]]) + (1-Y) %*% log(1 - A[[numLayers]]))
return(list(A = A, Z = Z, J = J))
}
letsee <- forwardPropagation(X,Y, parameters, 5, tanh)
letsee$A[[1]]
letsee$A[[2]]
letsee$A[[3]]
letsee$A[[4]]
letsee$A[[5]]
Y
m
log(letsee$A[[5]])
ln(letsee$A[[5]])
setwd("~/Documents/GitHub/PML-week4")
install.packages("caret")
install.packages("e1071")
training <- read.csv("pml-training.csv")
testing <- read.csv("pml-testing.csv")
nas <- is.na(training)
sums <- apply(nas, 2, sum)
train2 <- training[,sums <= 10000]
sum(is.na(train2))
levels(training$classe)
inbuild <- createDataPartition(y = training$classe, p = 0.7, list = FALSE)
validation <- train2[-inbuild,]
buildData <- train2[inbuild,]
library(caret)
inbuild <- createDataPartition(y = training$classe, p = 0.7, list = FALSE)
validation <- train2[-inbuild,]
buildData <- train2[inbuild,]
mod1 <- readRDS("./mod1.rds")
mod1_pred <- predict(mod1, newdata = validation)
mod1$finalModel
confusionMatrix(mod1_pred, validation$classe)
tmp <- validation[1:100,]
testData <- testing[, sums <= 10]
tmp2 <- merge(tmp, testData)
tmp2 <- rbind(tmp, testData)
tmp <- tmp[,-c("classe")]
tmp <- tmp[,-c(classe)]
tmp <- tmp[,-"classe"]
tmp <- tmp[,-classe]
tmp <- tmp[,-"classe"]
test_pred <- predict(mod1, newdata = testData)
levels(validation) == levels(validation)
tmp <- testData
is.na(tmp)
sum(is.na(tmp))
apply(tmp, 2, sum)
apply(tmp, 2, is.na)
tmp[is.na(tmp)] <- as.character(tmp[is.na(tmp)])
tmp(is.na())
tmp(is.na(tmp))
tmp[is.na(tmp)]
testna <- is.na(tmp)
View(testna)
tmp2 <- tmp
tmp2[, testna] <- ""
tmp2[, testna]
sumnas <- apply(testna, 2, sum)
sumnas
sumnas[, == 20]
for x in tmp2 { message(x)}
tmp2[, is.na(tmp2)] <- ""
ins.na(tmp2)
is.na(tmp2)
is.na(tmp2) <- ""
tmp2[is.na(tmp2)] <- ""
test_pred <- predict(mod1, newdata = tmp2)
View(test_pred)
View(tmp2)
mod3 <- train(classe~., method = "lm", data = buildData)
mod3 <- train(classe~., method = "svmlinear", data = buildData)
mod3 <- train(classe~., method = "svmLinear", data = buildData)
mod3
tr2 <- train2[,c("accel_forearm_x","accel_forearm_y", "accel_forearm_z", "total_accel_forearm", "accel_dumbbell_x", "accel_dumbbell_y", "accel_dumbbell_z", "total_accel_dumbbell", "accel_arm_x","accel_arm_y", "accel_arm_z", "total_accel_arm", "accel_belt_x","accel_belt_y", "accel_belt_z", "total_accel_belt")]
te2 <- testing[,c("accel_forearm_x","accel_forearm_y", "accel_forearm_z", "total_accel_forearm", "accel_dumbbell_x", "accel_dumbbell_y", "accel_dumbbell_z", "total_accel_dumbbell", "accel_arm_x","accel_arm_y", "accel_arm_z", "total_accel_arm", "accel_belt_x","accel_belt_y", "accel_belt_z", "total_accel_belt")]
trctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 3)
set.seed(3233)
tr2 <- train2[,c("classe", "accel_forearm_x","accel_forearm_y", "accel_forearm_z", "total_accel_forearm", "accel_dumbbell_x", "accel_dumbbell_y", "accel_dumbbell_z", "total_accel_dumbbell", "accel_arm_x","accel_arm_y", "accel_arm_z", "total_accel_arm", "accel_belt_x","accel_belt_y", "accel_belt_z", "total_accel_belt")]
mod3 <- train(classe ~., data = tr2, method = "svmLinear",
trControl=trctrl,
preProcess = c("center", "scale"),
tuneLength = 10)
mod3$finalModel
predict(mod3, newdata = te2)
build <- createDataPartition(y = tr2$classe, p = 0.7, list = FALSE)
valid <- tr2[-build,]
bData <- tr2[build,]
mod3$coefnames
mod3$pred
mod3$metric
mod3$bestTune
mod3$yLimits
